
Тема 10. Декораторы и исключения

Отчет по Теме #10 выполнил:

Хорасанлыев Аганяз 

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |


**Лабораторная работа №1**
___

**Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для
100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.**
```
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):

    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))

```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/lab1.png)

Выводы.

Этот код вычисляет 100-е число Фибоначчи. Функция fibonacci(n) рекурсивно определяет число Фибоначчи.
@lru_cache(None) - это декоратор, который "запоминает" результаты вычислений функции fibonacci для каждого аргумента n. Когда функция вызывается с аргументом, который уже был вычислен, она не пересчитывает его заново, а просто возвращает сохраненный результат. Это значительно ускоряет выполнение для больших чисел, превращая экспоненциальную сложность в линейную.

**Лабораторная работа №2**
___

**Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130.
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.**

```
def check(input_func):
    def output_func(*args):
        name = args[0]
        age = args[1]


        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/lab2.png)

Выводы.

1.  check(input_func): Это функция-декоратор. Она принимает другую функцию (input_func, которая будет декорирована) в качестве аргумента.
2.  output_func(*args): Это внутренняя функция, которую возвращает декоратор. Она будет вызываться вместо исходной input_func.
3.  Логика внутри output_func: Она извлекает name и age из переданных аргументов. Если age находится вне допустимого диапазона (меньше 0 или больше 130), она изменяет его на строку 'Недопустимый возраст'. Затем она вызывает оригинальную функцию (input_func) с name и (возможно, измененным) age.
4.  @check: Этот синтаксический сахар применяет декоратор check к функции personal_info. Это означает, что при каждом вызове personal_info, сначала будет выполняться логика output_func из декоратора, а затем, если условия соблюдены, вызовется сама personal_info.

**Лабораторная работа №3**
___

**Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string.
Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт.
Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.**

```
def data(*args):
    try:
        for i in range(len(args)):
            try:
                result = (args[i] * 15) // 10
                print(result)
            except Exception as ex:
               print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
   data(1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45)

```

Результат.
![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/lab3.png)

Выводы.

•   try...except блоки: Код обернут в try...except для перехвата ошибок. Если операция с числом успешна, выводится результат. Если аргумент является строкой (как 'Hello', 'i', и т.д.) и его нельзя умножить на число, возникает ошибка TypeError.
•   Обработка ошибок: Вместо того чтобы программа падала, ошибка TypeError перехватывается (except Exception as ex), и выводится сообщение об этой ошибке (например, "unsupported operand type(s) for //: 'str' and 'int'").
•   finally блок: Сообщение 'Вся информация обработана' всегда выводится в конце, независимо от того, были ли ошибки в процессе обработки или нет.
В итоге, функция пытается обработать все данные, выводит результаты для чисел и сообщения об ошибках для строк, а затем завершает работу с финальным сообщением.

**Лабораторная работа №4**
___

**Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация**

```
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
         print('Успешная регистрация')

if __name__ == '__main__':
    name = '12345678910'
    check_name(name)

```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/lab4.png)

Выводы.

1.  class NegativeValueException(Exception): pass: Определяется новый тип ошибки NegativeValueException. Он наследуется от стандартного Exception, что делает его полноценным исключением.
2.  check_name(name): Эта функция проверяет длину строки name.
3.  raise NegativeValueException(...): Если длина name превышает 10 символов, функция генерирует (выбрасывает) наше пользовательское исключение NegativeValueException с указанным сообщением.
4.  print('Успешная регистрация'): Если длина имени 10 или меньше, выводится это сообщение.

**Лабораторная работа №5**
___

**После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: 		init		() (вызывается при создании класса декоратора в программе) и 	call	() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.**

```
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__) 
        self.func() 
        print('> Проверка безопасного выключения') 

@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/lab5.png)

Выводы.

Этот код использует класс SiteChecker как декоратор.
1. Декоратор (@SiteChecker): Применяется к функции site(), передавая ее в SiteChecker.__init__.
2. SiteChecker.__init__(self, func): Вызывается один раз при определении функции site. Он сохраняет саму функцию site (как self.func) для последующего использования.
3. SiteChecker.__call__(self): Вызывается каждый раз, когда вы пытаетесь вызвать декорированную функцию site(). Он добавляет код до (Проверка перед запуском) и после (Проверка безопасного выключения) выполнения оригинальной функции (self.func(), то есть 'Усердная работа сайта').


**Самостоятельная работа №1**
___

**Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.
Подсказка: необходимо использовать модуль time Декоратор необходимо использовать для этой функции.Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы. Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.**

```
import time

def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        duration = end_time - start_time
        print(f"\n--- Функция '{func.__name__}' выполнена за {duration:.4f} секунд. ---")
        return result
    return wrapper
@time_it
def fibonacci():
    fib1 = fib2 = 1
    print("Последовательность Фибоначчи (первые 200 членов):")
    print(fib1, end=' ')
    print(fib2, end=' ')

    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/cam1.png)

Выводы.

Этот код использует декоратор time_it для измерения времени выполнения функции fibonacci.
1. @time_it над def fibonacci(): "оборачивает" функцию fibonacci.
2. wrapper():
  •  Записывает время до вызова fibonacci.
  •  Вызывает саму функцию fibonacci.
  •  Записывает время после завершения fibonacci.
  •  Вычисляет разницу (время выполнения) и выводит ее.

**Самостоятельная работа №2**
___
**Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.**

```
import os
class EmptyFileError(Exception):
    pass
def read_and_check_file(filename):
    print(f"\nПопытка прочитать файл: '{filename}'")
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
            if not content:
                raise EmptyFileError("файл пустой")
            else:
                print(f"--- Содержимое файла '{filename}': ---")
                print(content)
    except FileNotFoundError:
        print(f"Ошибка: Файл '{filename}' не найден.")
    except EmptyFileError as e:
        print(f"Ошибка: {e}")
    except Exception as e:
        print(f"Произошла непредвиденная ошибка при работе с файлом '{filename}': {e}")

if __name__ == '__main__':
    empty_file_name = "emptyFile.txt"
    data_file_name = "dateFile.txt"

    with open(empty_file_name, 'w', encoding='utf-8') as f:
        pass
    print(f"Создан пустой файл: '{empty_file_name}'")

    with open(data_file_name, 'w', encoding='utf-8') as f:
        f.write("Horasanlyyev Aganyaz\n")
        f.write("USUE\n")
        f.write("ПИЭ-23-1")
    print(f"Создан файл с данными: '{data_file_name}'")
    read_and_check_file(empty_file_name)
    read_and_check_file(data_file_name)

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/cam2.png)

Выводы.

1. Определено пользовательское исключение EmptyFileError.
2. Функция чтения (read_and_check_file) проверяет, пуст ли файл после чтения (if not content).
3. Если файл пуст, она генерирует (raise) EmptyFileError.
4. Основная программа использует блок try-except, чтобы перехватить это исключение (или FileNotFoundError, если файла нет).
5. В зависимости от ситуации выводится сообщение ("файл пустой") или содержимое файла.


**Самостоятельная работа №3**
___

**Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль**

```
def add_two_to_user_number():
    try:
        user_input_str = input("Введите число: ")
        number = int(user_input_str)
        result = 2 + number
        print(f"Результат: 2 + {number} = {result}")
    except ValueError:
       print("Ошибка: Неподходящий тип данных. Ожидалось число.")
    except Exception as e:
        print(f"Произошла непредвиденная ошибка: {e}")

if __name__ == "__main__":
    print("--- Тест 1: Корректный ввод (целое число) ---")
    add_two_to_user_number()
    print("\n--- Тест 2: Корректный ввод (отрицательное целое число) ---")
    add_two_to_user_number()
    print("\n--- Тест 3: Некорректный ввод (строка) ---")
    add_two_to_user_number()
    print("\n--- Тест 4: Некорректный ввод (пустая строка) ---")
    add_two_to_user_number()
    print("\n--- Тест 5: Корректный ввод (ноль) ---")
    add_two_to_user_number()
    print("\n--- Тест 6: Некорректный ввод (число с плавающей точкой) ---")
    add_two_to_user_number()

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/cam3.png)

Выводы.

1.  try: Мы пытаемся выполнить блок кода, который может вызвать ошибку (ввод пользователя и преобразование в число).
2.  int(user_input_str): Эта функция пытается перевести строку, введенную пользователем, в целое число.
3.  except ValueError: Если int() не может преобразовать строку она вызывает встроенное исключение ValueError. Наш except блок перехватывает его и выводит требуемое сообщение об ошибке.

**Самостоятельная работа №4**
___

**Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.**

```
import functools

class Logger:
    def __init__(self, func):
        self.func = func
        functools.update_wrapper(self, func)
        print(f"Logger для '{func.__name__}' готов.")

    def __call__(self, *args, **kwargs):
        print(f"\n[ЛОГ] => '{self.func.__name__}' (args={args}, kwargs={kwargs})")
        res = self.func(*args, **kwargs)
        print(f"[ЛОГ] <= '{self.func.__name__}', вернул: {res}")
        return res

@Logger
def add(x, y):
    print(f"  Вычисляю {x} + {y}")
    return x + y

@Logger
def hello(name):
    print(f"  Говорю привет {name}")
    return f"Привет, {name}!"

if __name__ == '__main__':
    print("--- Тест: add ---")
    add(10, 5)

    print("\n--- Тест: hello ---")
    hello("Мир")


```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/cam4.png)

Выводы.

Logger — это класс-декоратор.
1.  __init__: Запоминает декорируемую функцию (add, hello) при старте.
2.  __call__: Выполняется при каждом вызове декорированной функции. Он выводит сообщение "Вход...", затем вызывает оригинальную функцию, и наконец выводит сообщение "Выход..." с результатом.

**Самостоятельная работа №5**
___
**Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.**

```
class InvalidDataError(Exception):
    pass
def check_age(age):
    if not isinstance(age, int):
        raise TypeError("Возраст должен быть целым числом.")
    if not 0 < age <= 120:
        raise InvalidDataError(f"Возраст {age} некорректен. Ожидается от 1 до 120.")
    print(f"Возраст {age} принят.")

def process_list_with_min_length(data_list):
    if not isinstance(data_list, list):
        raise TypeError("Ожидался список.")
    if len(data_list) < 3:
        raise InvalidDataError(f"Список слишком короткий. Ожидалось минимум 3 элемента, получено {len(data_list)}.")
    print(f"Список из {len(data_list)} элементов обработан: {data_list}")

if __name__ == '__main__':
    print("--- Тест: check_age ---")
    try:
        check_age(25)
        check_age(150)
    except InvalidDataError as e:
        print(f"Ошибка возраста: {e}")
    except TypeError as e:
        print(f"Ошибка типа возраста: {e}")

    try:
        check_age("двадцать")
    except InvalidDataError as e:
        print(f"Ошибка возраста: {e}")
    except TypeError as e:
        print(f"Ошибка типа возраста: {e}")


    print("\n--- Тест: process_list_with_min_length ---")
    try:
        process_list_with_min_length([1, 2, 3, 4])
        process_list_with_min_length([1, 2])
    except InvalidDataError as e:
        print(f"Ошибка списка: {e}")
    except TypeError as e:
        print(f"Ошибка типа списка: {e}")

    try:
        process_list_with_min_length("строка")
    except InvalidDataError as e:
        print(f"Ошибка списка: {e}")
    except TypeError as e:
        print(f"Ошибка типа списка: {e}")

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema10/cam5.png)

Выводы.

1. InvalidDataError: Пользовательское исключение, которое создано для случаев, когда значение данных некорректно , но тип данных при этом может быть верным.
2. Функции check_age и process_list_with_min_length:
  •  Обе функции проверяют входные данные на тип и на корректность значения/содержимого (генерируя InvalidDataError, если данные не проходят логическую проверку).
3. Блоки try-except: В основной части кода показано, как вызывать эти функции и перехватывать специфические исключения (InvalidDataError и TypeError) по отдельности, чтобы предоставить точные и информативные сообщения об ошибках.
