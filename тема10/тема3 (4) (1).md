
Тема 10. Декораторы и исключения

Отчет по Теме #10 выполнил:

Хорасанлыев Аганяз 

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |


**Лабораторная работа №1**
___

**Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для
100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.**
```
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):

    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))

```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/lab1.png)

Выводы.

Этот код вычисляет 100-е число Фибоначчи. Функция fibonacci(n) рекурсивно определяет число Фибоначчи.
@lru_cache(None) - это декоратор, который "запоминает" результаты вычислений функции fibonacci для каждого аргумента n. Когда функция вызывается с аргументом, который уже был вычислен, она не пересчитывает его заново, а просто возвращает сохраненный результат. Это значительно ускоряет выполнение для больших чисел, превращая экспоненциальную сложность в линейную.

**Лабораторная работа №2**
___

**Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130.
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.**

```
def check(input_func):
    def output_func(*args):
        name = args[0]
        age = args[1]


        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/lab2.png)

Выводы.

1.  check(input_func): Это функция-декоратор. Она принимает другую функцию (input_func, которая будет декорирована) в качестве аргумента.
2.  output_func(*args): Это внутренняя функция, которую возвращает декоратор. Она будет вызываться вместо исходной input_func.
3.  Логика внутри output_func: Она извлекает name и age из переданных аргументов. Если age находится вне допустимого диапазона (меньше 0 или больше 130), она изменяет его на строку 'Недопустимый возраст'. Затем она вызывает оригинальную функцию (input_func) с name и (возможно, измененным) age.
4.  @check: Этот синтаксический сахар применяет декоратор check к функции personal_info. Это означает, что при каждом вызове personal_info, сначала будет выполняться логика output_func из декоратора, а затем, если условия соблюдены, вызовется сама personal_info.

**Лабораторная работа №3**
___

**Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string.
Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт.
Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.**

```
def data(*args):
    try:
        for i in range(len(args)):
            try:
                result = (args[i] * 15) // 10
                print(result)
            except Exception as ex:
               print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
   data(1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45)

```

Результат.
![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/lab3.png)

Выводы.

•   try...except блоки: Код обернут в try...except для перехвата ошибок. Если операция с числом успешна, выводится результат. Если аргумент является строкой (как 'Hello', 'i', и т.д.) и его нельзя умножить на число, возникает ошибка TypeError.
•   Обработка ошибок: Вместо того чтобы программа падала, ошибка TypeError перехватывается (except Exception as ex), и выводится сообщение об этой ошибке (например, "unsupported operand type(s) for //: 'str' and 'int'").
•   finally блок: Сообщение 'Вся информация обработана' всегда выводится в конце, независимо от того, были ли ошибки в процессе обработки или нет.
В итоге, функция пытается обработать все данные, выводит результаты для чисел и сообщения об ошибках для строк, а затем завершает работу с финальным сообщением.

**Лабораторная работа №4**
___

**Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация**

```
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
         print('Успешная регистрация')

if __name__ == '__main__':
    name = '12345678910'
    check_name(name)

```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/lab4.png)

Выводы.

1.  class NegativeValueException(Exception): pass: Определяется новый тип ошибки NegativeValueException. Он наследуется от стандартного Exception, что делает его полноценным исключением.
2.  check_name(name): Эта функция проверяет длину строки name.
3.  raise NegativeValueException(...): Если длина name превышает 10 символов, функция генерирует (выбрасывает) наше пользовательское исключение NegativeValueException с указанным сообщением.
4.  print('Успешная регистрация'): Если длина имени 10 или меньше, выводится это сообщение.

**Лабораторная работа №5**
___

**После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: 		init		() (вызывается при создании класса декоратора в программе) и 	call	() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.**

```
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__) 
        self.func() 
        print('> Проверка безопасного выключения') 

@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/lab55.png)

Выводы.

Этот код использует класс SiteChecker как декоратор.
1. Декоратор (@SiteChecker): Применяется к функции site(), передавая ее в SiteChecker.__init__.
2. SiteChecker.__init__(self, func): Вызывается один раз при определении функции site. Он сохраняет саму функцию site (как self.func) для последующего использования.
3. SiteChecker.__call__(self): Вызывается каждый раз, когда вы пытаетесь вызвать декорированную функцию site(). Он добавляет код до (Проверка перед запуском) и после (Проверка безопасного выключения) выполнения оригинальной функции (self.func(), то есть 'Усердная работа сайта').


**Самостоятельная работа №1**
___

**Напишите программу, которая преобразует 1 в 31. Для выполнения поставленной задачи необходимо обязательно и только один раз использовать:
• Цикл for
• *= 5
• += 1
Никаких других действий или циклов использовать нельзя**

```
x=1
x*=5
for _ in range(26):
    x+=1
print(x)

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/cam1.png)

Выводы.

Переменная x изначально равна 1, затем умножается на 5 (стала 5). В цикле for 26 раз прибавляется 1, в итоге x становится 31 и выводится на экран.


**Самостоятельная работа №2**
___
**Напишите программу, которая фразу «Hello World» выводит в обратном порядке, и каждая буква находится в одной строке консоли. При этом необходимо обязательно использовать любой цикл, а также программа должна занимать не более 3 строк в редакторе кода.**

```
text="Hello World"
for x in text[::-1]:
    print(x)
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/cam2.png)

Выводы.

- text[::-1] — срез строки, который переворачивает её задом наперёд.
- Цикл for перебирает каждый символ в обратной строке.
- print(x) выводит символ на отдельной строке.


**Самостоятельная работа №3**
___

**Напишите программу, на вход которой поступает значение из консоли, оно должно быть числовым и в диапазоне от 0 до 10 включительно (это необходимо учесть в программе). Если вводимое число не подходит по требованиям, то необходимо вывести оповещение об этом в консоль и остановить программу. Код должен вычислять в каком диапазоне находится полученное число. Нужно учитывать три диапазона:
• от 0 до 3 включительно
• от 3 до 6
• от 6 до 10 включительно
Результатом работы программы будет выведенный в консоль диапазон. Программа должна занимать не более 10 строчек в редакторе кода.**

```
x = int(input())
print(x)
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/cam3.png)

Выводы.

- Проверяем, что ввод — число (isdigit()).
- Преобразуем в int.
- Проверяем, что число в диапазоне 0–10.
- Определяем, в какой из трёх диапазонов попадает число, и выводим результат.


**Самостоятельная работа №4**
___

**Манипулирование строками. Напишите программу на Python, которая принимает предложение (на английском) в качестве входных данных от пользователя. Выполните следующие операции и отобразите результаты:
• Выведите длину предложения.
• Переведите предложение в нижний регистр.
• Подсчитайте количество гласных (a, e, i, o, u) в предложении.
• Замените все слова "ugly" на "beauty".
• Проверьте, начинается ли предложение с "The" и заканчивается ли на "end".
Проверьте работу программы минимум на 3 предложениях, чтобы охватить проверку всех поставленных условий.**

```
sentence = input("Введите предложение на английском: ")

print("Длина предложения:", len(sentence))

lower_sentence = sentence.lower()
print("Предложение в нижнем регистре:", lower_sentence)

vowels = 'aeiou'
count_vowels = sum(1 for char in lower_sentence if char in vowels)
print("Количество гласных:", count_vowels)

replaced_sentence = sentence.replace("ugly", "beauty")
print("Предложение после замены:", replaced_sentence)

starts_with_the = sentence.startswith("The")
ends_with_end = sentence.endswith("end")
print("Начинается с 'The':", starts_with_the)
print("Заканчивается на 'end':", ends_with_end)

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/cam4.png)

Выводы.

Вывод длины предложения-print("Длина предложения:", len(sentence))
Перевод в нижний регистр-lower_sentence = sentence.lower()
Замена слова "ugly" на "beauty"-replaced_sentence = sentence.replace("ugly", "beauty")
Проверка начала и конца предложения-
starts_with_the = sentence.startswith("The")
ends_with_end = sentence.endswith("end")



**Самостоятельная работа №5**
___
**Составьте программу, результатом которой будет данный вывод в консоль:**

```
memory = ' world'
string = 'hello'
values = [0, 2, 4, 6, 8, 10]
counter = 0

while counter != 10:
    if counter in values:
        print(string + memory)
    else:
        print(string)
    counter += 1

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema3/cam5.png)

Выводы.

- memory = ' world' — содержит пробел и слово "world" для добавления к "hello".
- string = 'hello' — основная часть строки.
- values = [0, 2, 4, 6, 8, 10] — индексы, на которых надо выводить "hello world".
- В цикле while от 0 до 9 (пока counter != 10) печатаем:
  - Если counter есть в списке values, то выводим "hello world".
  - Иначе — просто "hello".
- После каждого вывода увеличиваем counter на 1.
