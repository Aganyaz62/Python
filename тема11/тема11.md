
Тема 11. Итераторы и генераторы

Отчет по Теме #11 выполнил:

Хорасанлыев Аганяз 

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |
| Задание 6 |  |  |
| Задание 7 |  |  |
| Задание 8 |  |  |
| Задание 9 |  |  |
| Задание 10 |  |  |


**Лабораторная работа №1**
___

**Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev()**
```
numbers = [0,1,2,3,4,5]
for item in numbers:
    print(item)
```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/lab1.png)

Выводы.

Этот код:
1. Создает список numbers со значениями от 0 до 5.
2. Итерируется (проходит по очереди) по каждому элементу в этом списке.
3. На каждой итерации выводит текущий элемент на новой строке.

**Лабораторная работа №2**
___

**Класс итератор с гибкой настройкой и удобными применением**

```
class CountDown:
    def __init__(self, start):
        self.count = start + 1

    def __iter__(self):
        return self

    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count

if __name__ == "__main__":
    counter = CountDown(5)
    for i in counter:
        print(i)
```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/lab2.png)

Выводы.

В конструкторе (__init__) значение start увеличивается на 1, чтобы счетчик открылся с start.
Метод __iter__() возвращает сам объект, делая его итератором.
Метод __next__() уменьшает счетчик на 1 при каждом вызове.
Когда счетчик опустится ниже 0, выбрасывается StopIteration, чтобы завершить цикл.

**Лабораторная работа №3**
___

**Генератор списка**

```
a = [i ** 2 for i in range(1,5)]

print('a - ', a)
for i in a:
    print(i)

print('iter(a) - ', iter(a))
for i in a:
    print(i)
```

Результат.
![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/lab3.png)

Выводы.

a = [i ** 2 for i in range(1,5)] — создает список [1, 4, 9, 16].
Первый цикл for i in a: — перебирает и выводит все элементы списка.
print('iter(a) - ', iter(a)) — выводит объект итератора, созданного функцией iter(a).
Второй цикл for i in a: — снова перебирает список a и выводит элементы.

**Лабораторная работа №4**
___

**Выражения генераторы**

```
b = (i ** 2 for i in range(1,5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/lab4.png)

Выводы.

b = (i ** 2 for i in range(1,5)) — создает генератор, который генерирует квадраты чисел по очереди.
print(b) — выводит объект-генератор, например <generator object ...>.
Первый цикл for i in b: — перебирает и выводит квадраты (1, 4, 9, 16).
После этого генератор b "истощается".
Второй цикл for i in b: — ничего не выводит, потому что генератор уже исчерпан, и повторный перебор ничего не дает.


**Лабораторная работа №5**
___

**Такой же счетчик, как и в первом задании, только это генератор и использует yield**

```
def countdown(count):
    while count >= 0:
        yield count
        count -= 1

if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/lab5.png)

Выводы.

countdown(count) — функция-генератор, которая по шагам возвращает числа, начиная с count и уменьшая на 1, пока не достигнет 0.
В основном блоке создается объект counter — генератор.
Цикл for i in counter: перебирает и выводит числа 5, 4, 3, 2, 1, 0 по одному.


**Самостоятельная работа №1**
___

**Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.**

```
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
        print(a)

for number in fib(100):
    if number >= 200:
        break

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/cam1.png)

Выводы.
fib(n) — генератор, который по шагам выдает числа Фибоначчи.
В основном цикле ищем первое число, которое >= 200, и выводим его

**Самостоятельная работа №2**
___
**К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла**

```
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

with open("fib.txt", "w") as file:
    for number in fib(100):
        file.write(str(number) + "\n")
        if number >= 200:
            print(number)
            break
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema11/cam2.png)

Выводы.

Генерирует числа Фибоначчи.
Записывает каждое число в файл fib.txt.
При достижении числа, >= 200, выводит его и прерывает цикл.
