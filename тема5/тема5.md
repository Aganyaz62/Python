
Тема 5. Базовые коллекции: множества, списки 

Отчет по Теме #5 выполнил:

Хорасанлыев Аганяз 

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |
| Задание 6 |  |  |
| Задание 7 |  |  |
| Задание 8 |  |  |
| Задание 9 |  |  |
| Задание 10 |  |  |


**Лабораторная работа №1**
___

**Друзья предложили вам поиграть в игру “найди отличия и убери повторения (версия для программистов)”. Суть игры состоит в том, что на вход программы поступает два множества, а ваша задача вывести все элементы первого, которых нет во втором. А вы как раз недавно прошли множества и знаете их возможности, поэтому это не составит для вас труда.**
```
set_1 = {'White', 'Black', 'Red', 'Pink',4,5}
set_2 = {'Red', 'Green', 'Blue', 'Red',1,2,5}
print(set_1 - set_2)
```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab1.png)

Выводы.
Оператор - (разность множеств) возвращает новое множество, содержащее все элементы, которые присутствуют в первом множестве (set_1) и отсутствуют во втором множестве (set_2).
   
**Лабораторная работа №2**
___

**Напишите две одинаковые программы, только одна будет использовать set(), а вторая frozenset() и попробуйте к исходному множеству добавить несколько элементов**

```
a=set("abcdefg")
print(a)
for i in range(1,5):
    a.add(i)
print(a)


a=frozenset("abcdefg")
print(a)
for i in range(1,5):
    a.add(i)
print(a)

```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab2.png)
![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab22.png)

Выводы.
 set – это коллекция уникальных элементов, которую можно изменять (добавлять, удалять элементы) после создания.
 frozenset – это тоже коллекция уникальных элементов, но которую нельзя изменять (добавлять или удалять элементы) после создания. Оно "заморожено".

**Лабораторная работа №3**
___

**На вход в программу поступает список (минимальной длиной 2 символа). Напишите программу, которая будет менять первый и последний элемент списка. P.S. В Python есть прикольное свойство, благодаря которому эту задачу можно решить более красиво, использовав всего 2 сточки кода, если интересно можете самостоятельно найти это решение.**

```
def replace(input_list):
    memory = input_list[0]
    input_list[0] = input_list[-1]
    input_list[-1] = memory

    return input_list

print(replace(['a','b','c','d']))
```

Результат.
![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab3.png)

Выводы.

1. memory = input_list[0] сохраняет первый элемент ('a') во временную переменную memory.
2. input_list[0] = input_list[-1] помещает последний элемент ('d') на место первого. Список становится ['d','b','c','d'].
3. input_list[-1] = memory помещает сохраненный первый элемент ('a') на место последнего. Список становится ['d','b','c','a'].
4. Функция возвращает измененный список.



**Лабораторная работа №4**
___

**На вход в программу поступает список (минимальной длиной 10 символов). Напишите программу, которая выводит элементы с индексами от 2 до 6. В программе необходимо использовать “срез”.**

```
x=[12,45,85,96,74,154,798,3154,8448,96658,62,1214]
print(x[2:6])
```
Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab4.png)

Выводы.
выбирает элементы, начиная с индекса 2 (включительно) и до индекса 6 (не включительно).

**Лабораторная работа №5**
___

**Иван задумался о поиске «бесполезного» числа, полученного из списка. Суть поиска в следующем: он берет произвольный список чисел, находит самое большое из них, а затем делит его на длину списка. Студент пока не придумал, где может пригодиться подобное значение, но ищет у вас помощи в реализации такой функции useless().**

```
def useless(lst):
    return max(lst) / len(lst)

print(useless([4,7,9,1,51]))
print(useless([-15.5,59,48.6,-48,0,21.3,12,-74.6]))
print(useless([-35.4,12.7,-69,58,-41.1,0,-89.2,95]))
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab5.png)

Выводы.

Эта функция useless находит максимальное число в списке, а затем делит его на количество элементов в этом списке.

**Лабораторная работа №6**
___

**Ребята не могут определится каким супергероем они хотят стать. У них есть случайно составленный список супергероев, и вы должны определить кто из ребят будет каким супергероем. Необходимо использовать разделение списков**

```
superHeroes=['spiderman','superman','batman']
nikolay, vasiliy, ivan = superHeroes
print("Nikolay - ", nikolay)
print("Vasiliy - ", vasiliy)
print("Ivan - ", ivan)
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab6.png)


Выводы.
Каждый элемент списка superHeroes по очереди присваивается соответствующей переменной:

**Лабораторная работа №7**
___

**Вовочка, насмотревшись передачи “Слабое звено” решил написать программу, которая также будет находить самое слабое звено (минимальный элемент) и удалять его, только делать он это хочет не с людьми, а со списком. Помогите Вовочке с реализацией программы.**

```
a=[-25.8,45,12,0,78,-78.1,12.6,9]
a.sort()
print("Отсортированный список:\n",a)
a.pop(0)
print("Отсортированный список без наименьшего элемента:\n",a)

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab7.png)

a.sort(): Сортирует список a по возрастанию (от наименьшего к наибольшему)
a.pop(0): Удаляет элемент с индексом 0 (то есть первый элемент) из списка a

**Лабораторная работа №8**
___

**Михаил решил создать большой n-мерный список, для этого он случайным образом создал несколько списков, состоящих минимум из 3, а максимум из 10 элементов и поместил их в один большой список. Он также как и Иван не знает зачем ему это сейчас нужно, но надеется на то, что это пригодится ему в будущем.**

```
1.
from random import randint

def list_maker():
    a = [randint(1,100)] * randint(3,10)
    return a

if __name__ == '__main__':
    result = []
    for i in range(randint(1,5)):
        result.append(list_maker())

    print(result)
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab8.png)

Выводы.
•   result = []: Инициализирует пустой список с именем result.  В этот список будут добавляться результаты работы функции list_maker().
•   for i in range(randint(1,5))::  Запускает цикл.
    •   randint(1, 5): Генерирует случайное целое число между 1 и 5 (включительно). Это число определяет, сколько раз будет выполнен цикл (то есть сколько списков будет создано и добавлено в result).
    •   result.append(list_maker()):  Внутри цикла вызывается функция list_maker(), которая создает список случайных чисел.  Затем этот список добавляется в конец списка result.
•   print(result): Выводит на экран список result, который содержит несколько списков, каждый из которых состоит из одинаковых случайных чисел.

**Лабораторная работа №9**
___

**9)Вы работаете в ресторане и отвечает за статистику покупок, ваша задача сравнить между собой заказы покупателей, которые указаны в разном порядке. Реализуйте функцию superset(), которая принимает 2 множества. Результат работы функции: вывод в консоль одного из сообщений в зависимости от ситуации:
1- «Супермножество не обнаружено»
2– «Объект {X} является чистым супермножеством»
3– «Множества равны»**

```
def superset(set_1, set_2):
    if set_1 > set_2:
        print(f'Объект {set_1} является чистым супермножеством')
    elif set_1 == set_2:
        print('Множества равны')
    elif set_1 < set_2:
        print(f'Объект {set_2} является чистым супермножеством')
    else:
        print('Супермножество не обнаружено')


if __name__ == '__main__':
    superset({1,8,3,5},{3,5})
    superset({1,8,3,5},{5,3,8,1})
    superset({3,5},{5,3,8,1})
    superset({90,100},{3,5})
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab9.png)

Выводы.
Функция superset сравнивает два множества (set_1 и set_2) и определяет их отношение с помощью операторов:

**Лабораторная работа №10**
___

**Предположим, что вам нужно разобрать стопку бумаг, но нужно начать работу с нижней, “переверните стопку”. Вам дан произвольный список. Представьте его в обратном порядке. Программа должна занимать не более двух строк в редакторе кода.**

```
myList = [1,4,6,8,2]
print(myList[::-1])
```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema5/lab10.png)

Выводы.
 myList[::-1] создает копию списка myList с элементами, расположенными в обратном порядке.

**Самостоятельная работа №1**
___

**Дайте подробный комментарий для кода, написанного ниже. Комментарий нужен для каждой строчки кода, нужно описать что она делает. Не забудьте, что функции комментируются по-особенному**

```
from datetime import datetime            
from math import sqrt                    

def main(**kwargs):
    for key in kwargs.items():             
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  
        print(result)                  

if __name__ == '__main__':                
    start_time = datetime.now()           
    main(                                   
        one=[10, 3],                        
        two=[5, 4],
        three=[15, 13],
        four=[93, 53],
        five=[133, 15]
    )
    time_costs = datetime.now() - start_time  
    print(f"Время выполнения программы - {time_costs}") 

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema4/cam1.png)

Выводы.

from datetime import datetime            # Импортируем класс datetime из модуля datetime для работы с датой и временем
from math import sqrt                     # Импортируем функцию sqrt из модуля math для вычисления квадратного корня

def main(**kwargs):
    """Функция main принимает произвольное количество именованных аргументов (kwargs),
    где каждому ключу соответствует последовательность из двух чисел.
    Для каждого такого значения вычисляет гипотенузу по теореме Пифагора и печатает результат.
    Параметры:
        **kwargs: именованные аргументы вида name=[a, b]
    Возвращаемое значение:
        None (функция только печатает результаты)
    """
    for key in kwargs.items():             # Итерируем по парам (ключ, значение) словаря kwargs; .items() возвращает последовательность кортежей
        # key — это кортеж вида (имя_аргумента, значение_аргумента)
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  # Берём вторую часть кортежа (key[1]) — это список/кортеж [a, b],
                                                        # затем key[1][0] и key[1][1] — первые два числа.
                                                        # Возводим их в квадрат, складываем и берём квадратный корень -> длина гипотенузы.
        print(result)                       # Печатаем вычисленный результат для текущей пары

if __name__ == '__main__':                # Блок, который выполняется только при запуске этого файла как основного скрипта
    start_time = datetime.now()            # Фиксируем текущее время начала выполнения программы
    main(                                   # Вызываем функцию main с пятью именованными аргументами,
        one=[10, 3],                        # каждый аргумент — список/кортеж из двух чисел
        two=[5, 4],
        three=[15, 13],
        four=[93, 53],
        five=[133, 15]
    )
    time_costs = datetime.now() - start_time  # Вычисляем разницу между текущим временем и временем старта -> продолжительность выполнения
    print(f"Время выполнения программы - {time_costs}")  # Печатаем время выполнения в читаемом формате (timedelta)

**Самостоятельная работа №2**
___
**Напишите программу, которая будет заменять игральную кость с 6 гранями. Если значение равно 5 или 6, то в консоль выводится «Вы победили», если значения 3 или 4, то вы рекурсивно должны вызвать эту же функцию, если значение 1 или 2, то в консоль выводится «Вы проиграли». При этом каждый вызов функции необходимо выводить в консоль значение “кубика”. Для выполнения задания необходимо использовать стандартную библиотеку random. Программу нужно написать, используя одну функцию и “точку входа”**

```
import random

def roll():
    value = random.randint(1, 6)
    print(f"Кубик: {value}")

    if value in (5, 6):
        print("Вы победили")
    elif value in (1, 2):
        print("Вы проиграли")
    else:
        print("Повторный бросок...")
        roll()

if __name__ == '__main__':
    roll()

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema4/cam2.png)

Выводы.
- Функция roll() делает бросок (random.randint), печатает значение и в зависимости от него либо выводит результат (победа/поражение), либо при 3 или 4 рекурсивно вызывает себя для повторного броска.
- Блок if __name__ == '__main__': гарантирует, что бросок начнётся только при прямом запуске скрипта.

**Самостоятельная работа №3**
___

**Напишите программу, которая будет выводить текущее время, с точностью до секунд на протяжении 5 секунд. Программу нужно написать с использованием цикла. Подсказка: необходимо использовать модуль datetime и time, а также вам необходимо как-то “усыплять” программу на 1 секунду.**

```
from datetime import datetime as dt
import time

def show_time(seconds=5):


    for _ in range(seconds):
        print(dt.now().strftime('%H:%M:%S'))
        time.sleep(1)

if __name__ == '__main__':
    show_time(5)

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema4/cam3.png)

Выводы.

- datetime.now().strftime('%H:%M:%S') выводит текущее время до секунд.
- time.sleep(1) приостанавливает выполнение на 1 секунду, поэтому вывод происходит каждую секунду.
- Цикл for гарантирует ровно 5 выводов.


**Самостоятельная работа №4**
___

**Напишите программу, которая считает среднее арифметическое от аргументов вызываемое функции, с условием того, что изначальное количество этих аргументов неизвестно. Программу необходимо реализовать используя одну функцию и “точку входа”.**

```
def average(*args):
    if not args:
        print("Нет аргументов для вычисления среднего.")
        return None
    result = sum(args) / len(args)
    print(f"Среднее арифметическое для {args} = {result}")
    return result

if __name__ == '__main__':
    average(1, 2, 3, 4)
    average(10, 20)
    average()

```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema4/cam4.png)

Выводы.

- *args позволяет функции принимать любое количество позиционных аргументов.
- sum(args)/len(args) вычисляет среднее; перед этим проверяем, что аргументы есть, чтобы избежать деления на ноль.
- Блок if __name__ == '__main__': служит «точкой входа» и показывает примеры вызова функции.


**Самостоятельная работа №5**
___
**Создайте два Python файла, в одном будет выполняться вычисление площади треугольника при помощи формулы Герона (необходимо реализовать через функцию), а во втором будет происходить взаимодействие с пользователем (получение всей необходимой информации и вывод результатов). Напишите эту программу и выведите в консоль полученную площадь.**

```
def triangle_area(a, b, c):

    a = float(a)
    b = float(b)
    c = float(c)

    if a <= 0 or b <= 0 or c <= 0:
        raise ValueError("Длины сторон должны быть положительными.")
    if a + b <= c or a + c <= b or b + c <= a:
        raise ValueError("Стороны не удовлетворяют неравенству треугольника.")

    s = (a + b + c) / 2.0
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    return area


from labs import triangle_area

def main():
    try:
        a = input("Введите длину стороны a: ")
        b = input("Введите длину стороны b: ")
        c = input("Введите длину стороны c: ")

        area = triangle_area(a, b, c)
    except ValueError as e:
        print("Ошибка:", e)
        return
    except Exception as e:
        print("Неожиданная ошибка:", e)
        return

    print(f"Площадь треугольника: {area:.6f}")

if __name__ == "__main__":
    main()



```

Результат.

![skriny](https://github.com/Aganyaz62/Python/blob/main/skriny/tema4/cam5.png)

Выводы.

- Формула Герона: s = (a + b + c) / 2, площадь = sqrt(s (s-a) (s-b) (s-c)).
- В коде сначала проверяем, что стороны положительны и удовлетворяют неравенству треугольника, затем применяем формулу и возвращаем/выводим результат.
